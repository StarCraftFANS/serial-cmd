
这是一个把单字节通信协议封装成cmd+data形式包的协议，可方便地用于串口等单字节传输场合。

说明：

```c
一、包协议
  基本格式：
    包头 + 数据包长度高8位 + 数据包长度低8位 + 数据包
  包头格式：
    CMD_ESC+CMD_HEAD      表示包头
    CMD_ESC+CMD_DAT       表示是数据，数据值就是CMD_ESC
  发送端：
    包头    CMD_ESC+CMD_HEAD
    数据    检测并发送，当检测到数据是CMD_ESC时，则发送CMD_ESC+CMD_DAT
  接收端：
    检测到非CMD_ESC     认为是数据
    检测到CMD_ESC       进行标记，等待下一个数据
      下一个数据检测到CMD_HEAD    认为是包头
      下一个数据检测到CMD_DAT     认为是数据CMD_ESC
  总体数据格式：
    包头 + 数据包长度高位 + 数据包长度低位 + 数据包
    发送端和接收端在收发数据包长度时也会进行转义字符检测，防止数据正好和转义字符相同
  二、cmd协议
  cmd在包协议基础上，把包的内容进行封装，形成如下形式：
    命令高8位 + 命令低8位 + 数据长度高8位 + 数据长度低8位 + 数据
  发送端先根据cmd协议整合数据包内容，再通过数据包协议发送出去；
  接收端根据数据包协议解析，解析到数据包后再根据cmd协议解析出cmd，再回调函数。

使用：
  一、客制化部分
      1、客制化转义字符、包头、数据
      2、客制化发送缓冲区和接收的包缓冲区大小
  二、代码使用
      1、设置CMD_PLATFORM宏，并调通相应串口接口函数：发送接口函数package_uart_send()，接收接口函数cmd_check_data()
      1、用 cmd_set_call_back 接口设置接收到cmd后的回调函数
      2、cmd_send_cmd(uint16_t cmd, uint16_t len, uint8_t *p) 来发送一个cmd
      3、把串口接收到的数据传给 cmd_get_byte 或 cmd_get_buf，函数会对数据解析，当解析到一个完整的命令时会回调上面的函数
         或者直接调用本模块的cmd_check_data()函数来检测串口数据。
  长度：
      cmd是16位，2字节，最多支持65536个指令
      len是16位，2字节，最多支持长度是65536字节
```

